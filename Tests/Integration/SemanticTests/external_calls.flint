// RUN: %flintc %s --verify

contract Contract {

}

Contract :: (any) {
  func someFunc() {
      
  }

  func someReturningFunc() -> Int {
     return 42
  }

  public init() {
    // PARAMETER TESTS
    call! self.someFunc()

    do {
        call(gas: 100)! self.someFunc()
        call(value: Wei(100))! self.someFunc()
        call(value: Wei(100), gas: 100)! self.someFunc()

        call(gas: 100, value: Wei(200), gas: 300)! self.someFunc() // expected-error {{'gas' hyper-parameter was already specified}}
        call(value: Wei(100), value: Wei(200), value: Wei(300))! self.someFunc() // expected-error {{'value' hyper-parameter was already specified}}
        // expected-error@-1 {{'value' hyper-parameter was already specified}}

        call(Wei(100))! self.someFunc() // expected-error {{External call hyper-parameter was not labeled}}

        call(money: Wei(100))! self.someFunc() // expected-error {{'money' is not a valid external call hyper-parameter}}
    } catch is Error {

    }

    // RETURN/TYPE CHECKS
    call self.someFunc() // expected-error {{Cannot use `call` outside do-catch block}}

    call self.someReturningFunc() // expected-error {{Cannot use `call` outside do-catch block}}

    do {
        call self.someFunc()

        call self.someReturningFunc()

        let x: Int = call self.someReturningFunc()

        let y: Bool = call self.someReturningFunc() // expected-error {{Incompatible assignment between values of type 'Bool' and 'Int'}}
    } catch is Error {

    }

    call! self.someFunc()

    call! self.someReturningFunc()

    let x2: Int = call! self.someReturningFunc()

    let y2: Bool = call! self.someReturningFunc() // expected-error {{Incompatible assignment between values of type 'Bool' and 'Int'}}

    call? self.someFunc() // expected-error {{Cannot use `call?` with external function that has no return type}}

    let x: Int = call? self.someReturningFunc() // expected-error {{Assignment to the optional result of `call?` is not yet implemented}}
  }
}

